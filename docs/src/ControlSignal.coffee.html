<!doctype html>

<!-- Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc) -->

<html>
<head>
  <title>CoffeeDoc | ControlSignal.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" media="all" href="../resources/base.css" />
</head>
<body>
  <header>
    <h1>ControlSignal.coffee</h1>
  </header>
  <div class="container">
    <div class="sidebar column">
      
      <h4>Classes</h4>
      <ul class="classlist">
        
        <li><a href="#ControlSignal">ControlSignal</a></li>
        
      </ul>
      
      
    </div>
    <div class="content column">
      
      
      <div id="classes">
        <h2>Classes</h2>
        
        <div class="class">
          <div class="header">
            <a id="ControlSignal"><h3>ControlSignal</h3></a>
            
          </div>
          <div class="class-content">
            <p>The ControlSignal provides a simple and special signal-slot implementation.
However, this class goes beyond the Observer pattern, allowing the slots
to return values that ultimately influence the owner&#39;s operations.</p>
<p>The ControlSignal is a fully asynchronous class (where it counts). The emission
of a signal is an async operation. All of its slots must be async functions.</p>
<p>The ControlSignal itself does not define how it handles the &quot;return&quot; values of
the async slots. Instead, during construction, you must provide a processor.
This function receives an array of all the slots&#39; results and has full
control of what ultimately makes it to the emission callback.
Note that all slots calls are performed &quot;in parallel&quot; and then processsed
synchronously thereafter.</p>
<p>The ControlSignal provides some class functions that create special instances
with built-in processors. In fact, the ControlSignal should be treated as a
low-level class. Use the special class functions whenever possible.</p>

            <div class="methods">
              
              <div class="staticmethods">
                <h3>Static Methods</h3>
                
                <div class="method">
                  <h4>arrayControlSignal(paramCount)</h4>
                  <p>Builds an &quot;array&quot; ControlSignal. This ControlSignal will provide
all the slots&#39; results in an array to the emission callback.</p>
<p>See the ControlSignal constructor for more info.</p>

                </div>
                
                <div class="method">
                  <h4>vetoControlSignal(paramCount)</h4>
                  <p>Builds a &quot;veto&quot; ControlSignal. If all slots return true, true is given
to the emission callback. If just one slot returns false, false results.
In effect, each slot has &quot;veto&quot; power to force the return value to false.</p>
<p>See the ControlSignal constructor for more info.</p>

                </div>
                
                <div class="method">
                  <h4>voidControlSignal(paramCount)</h4>
                  <p>Builds a &quot;void&quot; ControlSignal. This ControlSignal will always provide
null to the emission callback.</p>
<p>See the ControlSignal constructor for more info.</p>

                </div>
                
              </div>
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>constructor(@paramCount, @processor)</h4>
                  <p>Constructs a new ControlSignal.</p>
<h5 id="arguments">Arguments</h5>
<p><code>@paramCount</code><br>The number of parameters the signal will emit, excluding the obligatory callback.
A ControlSignal cannot be variadic. This number must be 0 or greater.s</p>
<p><code>@processor</code><br>This function is called after all the slots have been executed. It is given an array of
all the slots&#39; results. Whatever the processor function returns is then given to the
emission callback. Note that this function is executed synchronously. It is given only
one parameter. If it throws an exception, it will be given to the emission callback as
the error.</p>
<h5 id="exceptions">Exceptions</h5>
<p>Throws RangeError if the <code>paramCount</code> is less than 0.</p>

                </div>
                
                <div class="method">
                  <h4>connect(slot)</h4>
                  <p>Registers a persistent, asynchronous slot.
If the slot was already registered, it will be registered
again and, therefore, invoked multiple times for each emission.</p>
<h5 id="arguments">Arguments</h5>
<p><code>slot</code><br>The slot. Must be a function. The last argument passed
to this function will always be the asynchronous callback which
must be called when the listener is done. The callback takes
two parameters: the error, if any, and the result. The result
is given to the emission callback after being processed by the
signal&#39;s processor.</p>
<p>The arity of the slot must match the <code>paramCount</code> of
the signal, taking the obligatory callback into consideration.
(That is, the arity must equal <code>paramcount + 1</code>.)</p>
<h5 id="returns">Returns</h5>
<p>null</p>
<h5 id="exceptions">Exceptions</h5>
<p>Throws Error if arity doesn&#39;t match signal&#39;s (see the definition of <code>slot</code>
above).</p>

                </div>
                
                <div class="method">
                  <h4>disconnect(slot)</h4>
                  <p>Removes a given slot.</p>
<p>If the slot was registered multiple times, only one
registration will be removed. The slot will continue
to be invoked by the other registrations.</p>
<h5 id="arguments">Arguments</h5>
<p><code>slot</code><br>The slot as provided to <code>connect</code>. Must be a function.</p>
<h5 id="returns">Returns</h5>
<p>True if a slot was removed; false otherwise.</p>

                </div>
                
                <div class="method">
                  <h4>receivers()</h4>
                  <p>Gets the number of slots registered.</p>
<h5 id="returns">Returns</h5>
<p>The number of slots registered.
If a slot was registered multiple times, it will be
included multiple times in the count.</p>

                </div>
                
                <div class="method">
                  <h4>emit(args..., callback)</h4>
                  <p>Emits the signal, calling all slots registered.</p>
<h5 id="arguments">Arguments</h5>
<p><code>args...</code><br>Arguments to pass to the slots, excluding the callback, which
is automatically provided for you. The number of arguments must therefore
be equal to the signal&#39;s <code>paramCount</code>.</p>
<p><code>callback(error, value)</code><br>The async callback. <code>error</code> will be the first error encountered
or <code>null</code> if none were. The <code>value</code> will be the result of the
reduce operation against all the slots&#39; results unless there
is an error, in which case it will be null.</p>
<h5 id="returns">Returns</h5>
<p>This is an asynchronous function. The results are provided to the
callback. However, the function itself returns null.</p>
<h5 id="exceptions">Exceptions</h5>
<p>Throws Error if the number of arguments does not equal the <code>paramCount</code>
(see the definition of <code>args...</code> above).</p>

                </div>
                
              </div>
              
              
            </div>
          </div>
        </div>
        
      </div>
      
      
    </div>
  </div>
</body>
</html>
