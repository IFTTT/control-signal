<!doctype html>

<!-- Documentation generated by [CoffeeDoc](http://github.com/omarkhan/coffeedoc) -->

<html>
<head>
  <title>CoffeeDoc | ControlSignal.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" media="all" href="../resources/base.css" />
</head>
<body>
  <header>
    <h1>ControlSignal.coffee</h1>
  </header>
  <div class="container">
    <div class="sidebar column">
      
      <h4>Classes</h4>
      <ul class="classlist">
        
        <li><a href="#ControlSignal">ControlSignal</a></li>
        
      </ul>
      
      
    </div>
    <div class="content column">
      
      
      <div id="classes">
        <h2>Classes</h2>
        
        <div class="class">
          <div class="header">
            <a id="ControlSignal"><h3>ControlSignal</h3></a>
            
          </div>
          <div class="class-content">
            <p>The ControlSignal provides a simple and special signal-slot implementation.
However, it should not be used to implement the Observer pattern per se
because it allows the creation of hooks that return values that influence
the owner&#39;s operations.</p>
<p>The ControlSignal is a fully asynchronous class (where it counts). The emission
of a signal is an async operation. All of its slots must be async functions.</p>
<p>The ControlSignal itself does not define how it handles the &quot;return&quot; values of
the async slots. Instead, during construction, you must provide an iterator and
initial value. These parameters are used to perform a reduce operation against
the results from all the slot calls. Note that all slots calls are performed
&quot;in parallel&quot; and then reduced synchronously thereafter.</p>
<p>The ControlSignal provides some class functions that create special instances
with built-in iterators.</p>

            <div class="methods">
              
              <div class="staticmethods">
                <h3>Static Methods</h3>
                
                <div class="method">
                  <h4>arrayControlSignal(arity)</h4>
                  <p>Builds an &quot;array&quot; ControlSignal. This ControlSignal will provide
all the slots&#39; results in an array to the emission callback.</p>
<p>See the ControlSignal constructor for more info.</p>

                </div>
                
                <div class="method">
                  <h4>vetoControlSignal(arity)</h4>
                  <p>Builds a &quot;veto&quot; ControlSignal. The value provided to the emission callback
is the result of performing a boolean AND operation against all the slots&#39; results.</p>
<p>See the ControlSignal constructor for more info.</p>

                </div>
                
                <div class="method">
                  <h4>voidControlSignal(arity)</h4>
                  <p>Builds a &quot;void&quot; ControlSignal. This ControlSignal will always provide
null to the emission callback.</p>
<p>See the ControlSignal constructor for more info.</p>

                </div>
                
              </div>
              
              
              <div class="instancemethods">
                <h3>Instance Methods</h3>
                
                <div class="method">
                  <h4>constructor(@arity, @iterator, @initialValue)</h4>
                  <p>Constructs a new ControlSignal.</p>
<h5 id="arguments">Arguments</h5>
<p><code>@arity</code><br>The arity of the signal, including the callback parameter. For example,
if the slots will take no parameters except for the callback, this should
be 1. The number of parameters given to emit and the arity of the slots
will be checked against this value; if they do not match, an exception
will be thrown as soon as possible.</p>
<p>There are two special values for this parameter. 0 indicates a varidaic signal;
slots must declare no parameters (instead using the special arguments variable),
and the signal will allow any number of parameters to be emitted. -1 disables
all arity checking. This should be used with extreme caution since an arity mismatch
will cause the callback to get lost and most likely cause the application to malfunction
horribly.</p>
<p><code>@iterator</code><br>The iterator function to be used to reduce all the results from the slots. This
function is synchronous and matches the iterator used by <code>Array.prototype.reduce</code>.
It is given four parameters, of which the last two are more or less irrelevant:</p>
<ul>
<li>The previous value of the accumulator.</li>
<li>The current value being processed.</li>
<li>The index of the slot whose result is currently being processed.</li>
<li>The array of slot results currently being processed.</li>
</ul>
<p><code>@initialValue</code><br>The initial value used during the reduce stage. It is mandatory because it also functions
as the default value provided to the emission callback when there are no slots.</p>
<h5 id="exceptions">Exceptions</h5>
<p>Throws RangeError if the arity is less than -1.</p>

                </div>
                
                <div class="method">
                  <h4>addSlot(slot)</h4>
                  <p>Registers a persistent, asynchronous slot.
If the slot was already registered, it will be registered
again and, therefore, invoked multiple times for each emission.</p>
<h5 id="arguments">Arguments</h5>
<p><code>slot</code><br>The slot. Must be a function. The last argument passed
to this function will always be the asynchronous callback which
must be called when the listener is done. The callback takes
two parameters: the error, if any, and the result. The result
is given to the emission callback depending on the signal&#39;s
reduce iterator.</p>
<p>The arity of the slot must match the arity of
the signal. If the signal&#39;s arity is 0, then the slot must be
variadic and declare no parameters. If the signal&#39;s arity is -1,
all arity checking is disabled.</p>
<h5 id="returns">Returns</h5>
<p>null</p>
<h5 id="exceptions">Exceptions</h5>
<p>Throws Error if arity doesn&#39;t match signal&#39;s (see the definition of <code>slot</code>
above).</p>

                </div>
                
                <div class="method">
                  <h4>removeSlot(slot)</h4>
                  <p>Removes a given slot.</p>
<p>If the slot was registered multiple times, only one
registration will be removed. The slot will continue
to be invoked by the other registrations.</p>
<h5 id="arguments">Arguments</h5>
<p><code>slot</code><br>The slot as provided to <code>addSlot</code>. Must be a function.</p>
<h5 id="returns">Returns</h5>
<p>True if a slot was removed; false otherwise.</p>

                </div>
                
                <div class="method">
                  <h4>slotCount()</h4>
                  <p>Gets the number of slots registered.</p>
<h5 id="returns">Returns</h5>
<p>The number of slots registered.
If a slot was registered multiple times, it will be
included multiple times in the count.</p>

                </div>
                
                <div class="method">
                  <h4>emit(args..., callback)</h4>
                  <p>Emits the signal, calling all slots registered.</p>
<h5 id="arguments">Arguments</h5>
<p><code>args...</code><br>Arguments to pass to the slots, excluding the callback, which
is automatically provided for you. The number of arguments must therefore
be equal to the signal&#39;s arity <em>minus 1</em>.
However, if the arity if 0 or -1 (indicating a variadic function or disabled
checking, respectively), the number of arguments is not checked.</p>
<p><code>callback(error, value)</code><br>The async callback. <code>error</code> will be the first error encountered
or <code>null</code> if none were. The <code>value</code> will be the result of the
reduce operation against all the slots&#39; results unless there
is an error, in which case it will be null.</p>
<h5 id="returns">Returns</h5>
<p>This is an asynchronous function. The results are provided to the
callback. However, the function itself returns null.</p>
<h5 id="exceptions">Exceptions</h5>
<p>Throws Error if the number of arguments does not match the arity
(see the definition of <code>args...</code> above).</p>

                </div>
                
              </div>
              
              
            </div>
          </div>
        </div>
        
      </div>
      
      
    </div>
  </div>
</body>
</html>
