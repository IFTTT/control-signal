// Generated by CoffeeScript 1.6.3
var ControlSignal, async,
  __slice = [].slice;

async = require('async');

/*
# ControlSignal module #

This module *is* the ControlSignal class.
You should really be looking at that instead!
*/


ControlSignal = (function() {
  /*
  The ControlSignal provides a simple and special signal-slot implementation.
  However, it should not be used to implement the Observer pattern per se
  because it allows the creation of hooks that return values that influence
  the owner's operations.
  
  The ControlSignal is a fully asynchronous class (where it counts). The emission
  of a signal is an async operation. All of its slots must be async functions.
  
  The ControlSignal itself does not define how it handles the "return" values of
  the async slots. Instead, during construction, you must provide a processor.
  This function receives an array of all the slots' results and has full
  control of what ultimately makes it to the emission callback.
  Note that all slots calls are performed "in parallel" and then processsed
  synchronously thereafter.
  
  The ControlSignal provides some class functions that create special instances
  with built-in processors. In fact, the ControlSignal should be treated as a
  low-level class. Use the special class functions whenever possible.
  */

  function ControlSignal(arity, processor) {
    this.arity = arity;
    this.processor = processor;
    /*
    Constructs a new ControlSignal.
    
    ##\##\# Arguments
    `@arity`  
    The arity of the signal, including the callback parameter. For example,
    if the slots will take no parameters except for the callback, this should
    be 1. The number of parameters given to emit and the arity of the slots
    will be checked against this value; if they do not match, an exception
    will be thrown as soon as possible.
    
    There are two special values for this parameter. 0 indicates a varidaic signal;
    slots must declare no parameters (instead using the special arguments variable),
    and the signal will allow any number of parameters to be emitted. -1 disables
    all arity checking. This should be used with extreme caution since an arity mismatch
    will cause the callback to get lost and most likely cause the application to malfunction
    horribly.
    
    `@processor`  
    This function is called after all the slots have been executed. It is given an array of
    all the slots' results. Whatever the processor function returns is then given to the
    emission callback. Note that this function is executed synchronously. It is given only
    one parameter. If it throws an exception, it will be given to the emission callback as
    the error.
    
    ##\##\# Exceptions
    Throws RangeError if the arity is less than -1.
    */

    if (this.arity < -1) {
      throw new RangeError("ControlSignal arity must be greater or equal to -1");
    }
    this._slots = [];
  }

  ControlSignal.prototype.connect = function(slot) {
    /*
    Registers a persistent, asynchronous slot.
    If the slot was already registered, it will be registered
    again and, therefore, invoked multiple times for each emission.
    
    ##\##\# Arguments
    `slot`  
    The slot. Must be a function. The last argument passed
    to this function will always be the asynchronous callback which
    must be called when the listener is done. The callback takes
    two parameters: the error, if any, and the result. The result
    is given to the emission callback after being processed by the
    signal's processor.
    
    The arity of the slot must match the arity of
    the signal. If the signal's arity is 0, then the slot must be
    variadic and declare no parameters. If the signal's arity is -1,
    all arity checking is disabled.
    
    ##\##\# Returns
    null
    
    ##\##\# Exceptions
    Throws Error if arity doesn't match signal's (see the definition of `slot`
    above).
    */

    if (slot.length !== this.arity && this.arity >= 0) {
      throw new Error("slot's arity does not match signal's (" + slot.length + " != " + this.arity + " including callback)");
    }
    this._slots.push(slot);
    return null;
  };

  ControlSignal.prototype.disconnect = function(slot) {
    /*
    Removes a given slot.
    
    If the slot was registered multiple times, only one
    registration will be removed. The slot will continue
    to be invoked by the other registrations.
    
    ##\##\# Arguments
    `slot`  
    The slot as provided to `connect`. Must be a function.
    
    ##\##\# Returns
    True if a slot was removed; false otherwise.
    */

    var i, s, _i, _ref;
    _ref = this._slots;
    for (i = _i = _ref.length - 1; _i >= 0; i = _i += -1) {
      s = _ref[i];
      if (s === slot) {
        this._slots.splice(i, 1);
        return true;
      }
    }
    return false;
  };

  ControlSignal.prototype.receivers = function() {
    /*
    Gets the number of slots registered.
    
    ##\##\# Returns
    The number of slots registered.
    If a slot was registered multiple times, it will be
    included multiple times in the count.
    */

    return this._slots.length;
  };

  ControlSignal.prototype.emit = function() {
    var args, callback, _i,
      _this = this;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
    /*
    Emits the signal, calling all slots registered.
    
    ##\##\# Arguments
    `args...`  
    Arguments to pass to the slots, excluding the callback, which
    is automatically provided for you. The number of arguments must therefore
    be equal to the signal's arity *minus 1*.
    However, if the arity if 0 or -1 (indicating a variadic function or disabled
    checking, respectively), the number of arguments is not checked.
    
    `callback(error, value)`  
    The async callback. `error` will be the first error encountered
    or `null` if none were. The `value` will be the result of the
    reduce operation against all the slots' results unless there
    is an error, in which case it will be null.
    
    ##\##\# Returns
    This is an asynchronous function. The results are provided to the
    callback. However, the function itself returns null.
    
    ##\##\# Exceptions
    Throws Error if the number of arguments does not match the arity
    (see the definition of `args...` above).
    */

    if (arguments.length !== this.arity && this.arity > 0) {
      throw new Error("incorrect number of arguments provided (got " + arguments.length + ", expected " + this.arity + " including callback)");
    }
    async.map(this._slots, function(slot, iteratorCallback) {
      return slot.apply(null, __slice.call(args).concat([iteratorCallback]));
    }, function(error, slotsResults) {
      var emissionError, result;
      if (error != null) {
        return callback(error, null);
      } else {
        try {
          result = _this.processor(slotsResults);
        } catch (_error) {
          emissionError = _error;
        }
        return callback(emissionError, result);
      }
    });
    return null;
  };

  ControlSignal.arrayControlSignal = function(arity) {
    /*
    Builds an "array" ControlSignal. This ControlSignal will provide
    all the slots' results in an array to the emission callback.
    
    See the ControlSignal constructor for more info.
    */

    return new ControlSignal(arity, function(slotsResults) {
      return slotsResults;
    });
  };

  ControlSignal.vetoControlSignal = function(arity) {
    /*
    Builds a "veto" ControlSignal. The value provided to the emission callback
    is the result of performing a boolean AND operation against all the slots' results.
    
    See the ControlSignal constructor for more info.
    */

    return new ControlSignal(arity, function(slotsResults) {
      return slotsResults.every(function(x) {
        return x;
      });
    });
  };

  ControlSignal.voidControlSignal = function(arity) {
    /*
    Builds a "void" ControlSignal. This ControlSignal will always provide
    null to the emission callback.
    
    See the ControlSignal constructor for more info.
    */

    return new ControlSignal(arity, function() {
      return null;
    });
  };

  return ControlSignal;

})();

module.exports = ControlSignal;
